VERSION 1.0 CLASS
BEGIN
  MultiUse = -1  'True
END
Attribute VB_Name = "ChrTranEncryptDecryptClass"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = False
Attribute VB_Exposed = False
Option Explicit

' ============================== CREDITS AND LICENSE =============================== '
' LICENSE & ACKNOWLEDGMENTS
'
' CLASS CHRTRAN ENCRYPT DECRYPT v1.0.0
' MIT License
'
' Copyright (c) 2020 - 2021
' Roberto Carlos Romay Medina
'
' Permission is hereby granted, free of charge, to any person obtaining a copy
' of this software and associated documentation files (the "Software"), to deal
' in the Software without restriction, including without limitation the rights
' to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
' copies of the Software, and to permit persons to whom the Software is
' furnished to do so, subject to the following conditions:
'
' The above copyright notice and this permission notice shall be included in all
' copies or substantial portions of the Software.
'
' THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
' IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
' FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
' AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
' LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
' OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
' SOFTWARE.
'
'
' Acknowledgments to
'  - Harvey Triana (Twitter: @HarveyTriana)
'  - VSCode v1.41.0+
'  - MS Excel v1911+
'  - VBA7.1 V1091+
'
'
' GitHub: https://github.com/roccouu/
' ExcliqLite's home page: https://roccouu.github.io/ChrTranEncryptDecryptClass/
' ExcliqLite's repo: https://github.com/Roccouu/ChrTranEncryptDecryptClass
' 2021, POTOSÍ - BOLÍVIA
' ============================== CREDITS AND LICENSE =============================== '


' ==================== CLASS CHRTRAN ENCRYPT DECRYPT STRUCTURE ===================== '
' DESCRIPTION ---------------------------------------------------------------------- '
' This algorithm allows encryption/decryption of text.
' Parameters required: a text to enc/dec, optionally a key text or a key text self
' generated by the algorithm and a parameter to choice the position of the key text in
' the final result.
' This algorithm is a improved work with little changes and based absolutelly
' on the Triana's algorithms.
' Thanks Mr. Triana for your talent!.
'
' VARIABLES CUSTOM (GLOEnu|Typ_) ----------------------------------------------------'
' CORE METHODS LIST (PRIVATE) ------------------------------------------------------ '
' ChrTran_EncryptDecrypt
' ChrTran_EncryptDecryptStringA
' ChrTran_EncryptDecryptStringB
' ChrTran_RandomNumber
' ChrTran_RandomWord
' Chrtran_encdec_static
' Chrtran_encdec_dynamic
' Chrtran_encdec
' ASSETS --------------------------------------------------------------------------- '
' ChrTran_asc_split
' ERRORS MANNAGEMENT AND ASSERTSIONS ----------------------------------------------- '
' Error_handler
' Debug_assert
' Debug_print
' Debug_msgbox
' CORE METHODS LIST (PUBLIC) ------------------------------------------------------- '
' CHRTRANGenerateRandomKey
' CHRTRANEncryptDecrypt
' ==================== CLASS CHRTRAN ENCRYPT DECRYPT STRUCTURE ===================== '


' ==================== CLASS CHRTRAN ENCRYPT DECRYPT STRUCTURE ===================== '
' VARIABLES CUSTOM (GLOEnu|Typ_) ----------------------------------------------------'
Public Enum CTED_ENCDEC
  ctedEncrypt
  ctedDecrypt
End Enum

Public Enum CTED_KEYPOS
  ctedLeft
  ctedRight
  ctedRandom
End Enum

Public Enum CTED_TYPERES
  ctedStatic
  ctedDynamic
End Enum

Public Enum CTED_KEYLENGTH
  ctedKeyLengthRandom
  ctedKeyLength1
  ctedKeyLength2
  ctedKeyLength3
  ctedKeyLength4
  ctedKeyLength5
  ctedKeyLength6
  ctedKeyLength7
  ctedKeyLength8
  ctedKeyLength9
  ctedKeyLength10
End Enum


' CORE METHODS LIST (PRIVATE) ------------------------------------------------------ '
Private Function ChrTran_EncryptDecrypt(ByVal UserText As String, ByVal UserKey As String, ByVal EncDec As CTED_ENCDEC) As String
  'Source: http://www.geocities.ws/yennyqm/hwct/ii/local4.html
  '--------------------------------------------------------------------- _
    EncryptString _
    Optimizing by Harvey T. _
   --------------------------------------------------------------------
  '--------------------------------------------------------------------- _
    ChrTran _
    Optimizing by Harvey T. _
   ---------------------------------------------------------------------
  '--------------------------------------------------------------------- _
    EncryptString + ChrTran _
    ReOptimizing by Roccou. (2020) _
   --------------------------------------------------------------------
  'ChrTran and EncryptDecrypt are an encryption/decryption algorithms created by Harvey Triana (Twitter: @HarveyTriana) _
   ChrTranEncryptDecryptClass is a improved algorithm with little changes and based absolutelly on the Triana's algorithms. Thanks Mr. Triana for your talent!.
  
  Dim VecUserTxtASCII As Variant
  Dim VecUserKeyASCII As Variant
  Dim StrResult As String
  Dim IntTemp As Integer, i As Integer, j As Integer
  
  On Error GoTo EH
  
  Let ChrTran_EncryptDecrypt = VBA.vbNullString
  
  ' //Get UserKey characters
  Let VecUserTxtASCII = ChrTran_asc_split(UserText)

  ' //Get UserText characters
  Let VecUserKeyASCII = ChrTran_asc_split(UserKey)

  ' //Encryption/Decryption
  For i = LBound(VecUserTxtASCII) To UBound(VecUserTxtASCII)
    Let j = IIf(i + 1 >= UBound(VecUserKeyASCII), LBound(VecUserTxtASCII), i)
    Let IntTemp = VecUserTxtASCII(i) + (VecUserKeyASCII(j) * IIf(EncDec = ctedEncrypt, 1, -1))
    Let IntTemp = IntTemp + IIf(EncDec = ctedEncrypt, IIf(IntTemp > 255, -255, 0), IIf(IntTemp < 0, 255, 0))
    Let StrResult = StrResult + VBA.Chr$(IntTemp)
  Next i
  
  ' //Return
  Let ChrTran_EncryptDecrypt = StrResult
  
EH:
  Let VecUserTxtASCII = Empty
  Let VecUserKeyASCII = Empty
  If Not VBA.Err.Number = 0 Then Call Debug_print("ERROR: ", VBA.Err.Number, ": ", VBA.Err.Description)
  On Error GoTo 0
  
End Function

Private Function ChrTran_EncryptDecryptStringA(ByVal UserText As String, ByVal EncDec As CTED_ENCDEC) As String
  
  ' To generate static characters from ascii's 70
  Dim UserTextASCII As Variant ' () As String
  Dim CharKeysASCII As Variant '() As String
  Dim StrPreReult As String
  Dim i As Integer, j As Integer
  
  Const STR_KEY As String = "&" ' Magic char.
  Const SNG_KEY As Single = 70 ' This constant could be a random value: 70 or 80 to have more strong results.
  Const SNG_LEN As Single = 3
  
  On Error GoTo EH
  Let ChrTran_EncryptDecryptStringA = VBA.vbNullString
  
  If EncDec = ctedEncrypt Then ' Encrypt
    
    Let UserTextASCII = ChrTran_asc_split(UserText)  ' 88,89,90
    For i = LBound(UserTextASCII) To UBound(UserTextASCII)
      Let CharKeysASCII = ChrTran_asc_split(VBA.CStr(UserTextASCII(i)), CBooAsc:=False) ' 88
      For j = LBound(CharKeysASCII) To UBound(CharKeysASCII)
        Let CharKeysASCII(j) = VBA.Chr$(SNG_KEY + VBA.CInt(CharKeysASCII(j))) ' 78,78
      Next
      Let StrPreReult = VBA.Join(CharKeysASCII, VBA.vbNullString) ' 78,78->N,N->NN, ... -78,79->N,M->NM
      Let j = SNG_LEN - VBA.Len(StrPreReult)
      Let UserTextASCII(i) = StrPreReult & IIf(j = 0, VBA.vbNullString, VBA.String$(j, STR_KEY)) ' 78,78->N,N->NN, ... -78,79->N,M->NM
      Let CharKeysASCII = Empty
    Next i
    
  Else ' Decrypt
    
    Let UserTextASCII = ChrTran_asc_split(UserText, SNG_LEN, False) ' NN-NM... -> NN, NM
    For i = LBound(UserTextASCII) To UBound(UserTextASCII)
      Let StrPreReult = VBA.Replace(VBA.CStr(UserTextASCII(i)), STR_KEY, VBA.vbNullString)
      Let CharKeysASCII = ChrTran_asc_split(StrPreReult, CBooAsc:=False) ' 78,78
      For j = LBound(CharKeysASCII) To UBound(CharKeysASCII)
        Let CharKeysASCII(j) = VBA.Asc(CharKeysASCII(j)) - SNG_KEY ' 78,78
      Next
      Let UserTextASCII(i) = VBA.Chr$(VBA.CInt(VBA.Join(CharKeysASCII, VBA.vbNullString))) ' 78,78->N,N->NN, ... -78,79->N,M->NM
      Let CharKeysASCII = Empty
    Next i
    
  End If
  
  Let ChrTran_EncryptDecryptStringA = VBA.Join(UserTextASCII, VBA.vbNullString)
  
EH:
  Let UserTextASCII = Empty
  Let CharKeysASCII = Empty
  If VBA.Err.Number <> 0 Then Call Debug_print("ERROR: ", VBA.Err.Number, ": ", VBA.Err.Description)
  On Error GoTo 0
  
End Function

Private Function ChrTran_EncryptDecryptStringB(ByVal UserText As String, ByVal EncDec As CTED_ENCDEC) As String
  
  ' To generate Absolutely random characters
  Dim UserTextASCII As Variant
  Dim CharKeysASCII As Variant
  Dim StrPreReult As String
  Dim x As Long, y As Long
  Dim SngKey As Long  ' This constant could be a random value: 70 or 80 to have more strong results.
  Dim i As Integer, j As Integer
  
  Const STR_KEY As String = "&" ' Magic char.
  Const SNG_LEN As Single = 3
  
  On Error GoTo EH
  Let ChrTran_EncryptDecryptStringB = VBA.vbNullString
  
  If EncDec = ctedEncrypt Then ' Encrypt
    
    Let SngKey = ChrTran_RandomNumber(48, 119) ' Random long generator between 80-120, This number allows random characters to the final password
    Let UserTextASCII = ChrTran_asc_split(UserText)  ' 88,89,90
    For i = LBound(UserTextASCII) To UBound(UserTextASCII)
      Let CharKeysASCII = ChrTran_asc_split(VBA.CStr(UserTextASCII(i)), CBooAsc:=False) ' 88
      For j = LBound(CharKeysASCII) To UBound(CharKeysASCII)
        Let CharKeysASCII(j) = VBA.Chr$(SngKey + VBA.CInt(CharKeysASCII(j))) ' 78,78
      Next
      Let StrPreReult = VBA.Join(CharKeysASCII, VBA.vbNullString) ' 78,78->N,N->NN, ... -78,79->N,M->NM
      Let j = SNG_LEN - VBA.Len(StrPreReult)
      Let UserTextASCII(i) = StrPreReult & IIf(j = 0, VBA.vbNullString, VBA.String$(j, STR_KEY)) ' 78,78->N,N->NN, ... -78,79->N,M->NM
      Let CharKeysASCII = Empty
    Next i
    
  Else ' Decrypt
    
    Let UserTextASCII = ChrTran_asc_split(UserText, SNG_LEN, False) ' NN-NM... -> NN, NM
    For i = LBound(UserTextASCII) To UBound(UserTextASCII)
      Let StrPreReult = VBA.Replace(VBA.CStr(UserTextASCII(i)), STR_KEY, VBA.vbNullString)
      Let CharKeysASCII = ChrTran_asc_split(StrPreReult, CBooAsc:=False) ' 78,78
      For j = LBound(CharKeysASCII) To UBound(CharKeysASCII)
        Let y = VBA.Asc(CharKeysASCII(j)) ' 55, 66, ...101
        Let x = y Mod 10 ' 5, 6, ...1
        Let x = y - x ' 50, 60, ...100
        Let CharKeysASCII(j) = y - x ' USERKEY ON ASCII
      Next
      Let UserTextASCII(i) = VBA.Chr$(VBA.CInt(VBA.Join(CharKeysASCII, VBA.vbNullString))) ' 78,78->N,N->NN, ... -78,79->N,M->NM
      Let CharKeysASCII = Empty
    Next i
    
  End If
  
  Let ChrTran_EncryptDecryptStringB = VBA.Join(UserTextASCII, VBA.vbNullString)
  
EH:
  Let UserTextASCII = Empty
  Let CharKeysASCII = Empty
  If VBA.Err.Number <> 0 Then Call Debug_print("ERROR: ", VBA.Err.Number, ": ", VBA.Err.Description)
  On Error GoTo 0
  
End Function

Private Function ChrTran_RandomNumber(ByVal LowNum As Long, ByVal UpNum As Long) As Long
  
  Dim N As Long, x As Single
  
  Call Application.Volatile
  Call VBA.Randomize
  Let N = VBA.CLng((((UpNum - LowNum) + 1) * VBA.Rnd) + LowNum)
  Let x = N Mod 10
  Let ChrTran_RandomNumber = N - x
  
End Function

Private Function ChrTran_RandomWord(Optional CSngLowWord As Single = 65, Optional CSngUpWord As Single = 90, Optional CSngStrLen As Long = 5) As String
  
  ' GENERATES A RANDOM STRING WITH CARACTERS BETWEEN A LOWWORD-UPWORD WITH ASCII CODES 0-255 AND A SELECTED LENGTH, BY DEFAULT: 65-90 OR A-Z AND LENGTH: 5
  Dim StrRand As String
  Dim i As Integer
  
  On Error GoTo EH
  
  ' Validate params
  Let CSngLowWord = IIf(CSngLowWord >= CSngUpWord, 65, CSngLowWord)
  Let CSngUpWord = IIf(CSngUpWord <= CSngLowWord, 90, CSngUpWord)
  Call Application.Volatile
  If CSngStrLen <= 0 Then
    Call VBA.Randomize(10)
    Let CSngStrLen = (10 * VBA.Rnd) + 1
  Else
    Let CSngStrLen = IIf(CSngStrLen >= 10, 10, CSngStrLen)
  End If
  
  ' Define default result to avoid errors
  Let ChrTran_RandomWord = VBA.String(CSngStrLen, VBA.Chr$(CSngLowWord))
  
  ' Generate random word
  Let i = 0
  Do
    Let i = i + 1
    Call VBA.Randomize
    Let StrRand = StrRand & VBA.Chr(VBA.Int((CSngUpWord - CSngLowWord + 1) * VBA.Rnd + CSngLowWord))
  Loop Until i = CSngStrLen
  
  ' Return
  Let ChrTran_RandomWord = StrRand
  
EH:
  Call Debug_print("CHRTRAN::-random_word: ", VBA.Err.Description)
  On Error GoTo 0
  
End Function

' Enc/Dec methods
Private Function Chrtran_encdec_static(ByVal UserText As String, ByVal UserKey As String, ByVal EncDec As CTED_ENCDEC) As String
  
  On Error GoTo EH
  
  If EncDec = ctedEncrypt Then ' Encrypt
    Let Chrtran_encdec_static = ChrTran_EncryptDecryptStringA(ChrTran_EncryptDecrypt(UserText, UserKey, EncDec), EncDec)
  Else ' Decrypt
    Let Chrtran_encdec_static = ChrTran_EncryptDecrypt(ChrTran_EncryptDecryptStringA(UserText, EncDec), UserKey, EncDec)
  End If
  
EH:
  Call Error_handler
  
End Function

Private Function Chrtran_encdec_dynamic(ByVal UserText As String, ByVal UserKey As String, ByVal EncDec As CTED_ENCDEC) As String
  
  On Error GoTo EH
  
  If EncDec = ctedEncrypt Then
    Let Chrtran_encdec_dynamic = ChrTran_EncryptDecryptStringB(ChrTran_EncryptDecrypt(UserText, UserKey, EncDec), EncDec)
  Else
    Let Chrtran_encdec_dynamic = ChrTran_EncryptDecrypt(ChrTran_EncryptDecryptStringB(UserText, EncDec), UserKey, EncDec)
  End If
  
EH:
  Call Error_handler
  
End Function

Private Function Chrtran_encdec( _
  ByVal UserText As String, _
  ByVal UserKey As String, _
  ByVal EncDec As CTED_ENCDEC, _
  ByVal RndKeyLength As CTED_KEYLENGTH, _
  ByVal RndKeyPosition As CTED_KEYPOS, _
  ByVal ResultType As CTED_TYPERES) As String
  
  Dim VecAux0 As Variant
  Dim StrKey As String, StrFinalText As String, StrKeyLeft As String, StrKeyRight As String, StrHashLeft As String, StrHashRight As String
  Dim i As Long
  
  Const STR_DELIM As String = "$"
  Const STR_HASHK As String = "#"
  
  On Error GoTo EH
  
  ' Validation
  If UserText = VBA.vbNullString Then GoTo EH
  
  ' Determine key
  Let StrKey = UserKey
  If EncDec = ctedEncrypt Then
    If StrKey = VBA.vbNullString Then Let StrKey = ChrTran_RandomWord(CSngStrLen:=RndKeyLength)
  Else
    If StrKey = VBA.vbNullString Then ' There's no user key
      ' Key is included in encrypted text
      Let VecAux0 = VBA.Split(UserText, STR_DELIM)
      Let i = IIf(VBA.InStr(VBA.CStr(VecAux0(0)), STR_HASHK) > 0, 0, 1)
      Let StrKey = VBA.Replace(VBA.CStr(VecAux0(i)), STR_HASHK, VBA.vbNullString)
      Let UserText = VBA.CStr(VecAux0(IIf(i = 0, 1, 0)))
      Let VecAux0 = Empty
    End If
  End If
  
  ' Encrypt/Decrypt
  If ResultType = ctedStatic Then
    Let StrFinalText = Chrtran_encdec_static(UserText, StrKey, EncDec)
  Else
    Let StrFinalText = Chrtran_encdec_dynamic(UserText, StrKey, EncDec)
  End If
  If EncDec = ctedEncrypt And RndKeyPosition = ctedRandom Then
    Let i = VBA.CLng(2 * VBA.Rnd) + 1
    Let RndKeyPosition = IIf(i <= 1, ctedLeft, ctedRight)
  End If
  Let i = VBA.CLng(2 * VBA.Rnd) + 1
  Let StrHashLeft = IIf(UserKey = VBA.vbNullString, IIf(i <= 1, STR_HASHK, VBA.vbNullString), VBA.vbNullString)
  Let StrHashRight = IIf(UserKey = VBA.vbNullString, IIf(i >= 2, STR_HASHK, VBA.vbNullString), VBA.vbNullString)
  Let StrKeyLeft = IIf(UserKey = VBA.vbNullString, IIf(EncDec = ctedEncrypt, IIf(RndKeyPosition = ctedLeft, StrHashLeft & StrKey & StrHashRight & STR_DELIM, VBA.vbNullString), VBA.vbNullString), VBA.vbNullString)
  Let StrKeyRight = IIf(UserKey = VBA.vbNullString, IIf(EncDec = ctedEncrypt, IIf(RndKeyPosition = ctedRight, STR_DELIM & StrHashLeft & StrKey & StrHashRight, VBA.vbNullString), VBA.vbNullString), VBA.vbNullString)
  
  ' Return
  Let Chrtran_encdec = StrKeyLeft & StrFinalText & StrKeyRight
  
EH:
  Call Error_handler
  
End Function



' ASSETS --------------------------------------------------------------------------- '
Private Function ChrTran_asc_split(ByVal CStrText As String, Optional CIntLength As Integer = 1, Optional CBooAsc As Boolean = True) As Variant
  
  Dim VecTextASCII As Variant
  Dim StrAsc As String
  Dim i As Long, j As Long
  
  On Error GoTo EH
  
  Let CIntLength = IIf(VBA.Abs(CIntLength) = 0 Or VBA.Abs(CIntLength) > VBA.Len(CStrText), 1, VBA.Abs(CIntLength))
  
  ' //Get CStrText characters
  ReDim VecTextASCII(0)
  Let j = 0
  For i = 1 To VBA.Len(CStrText) Step CIntLength ' Little VBA's defect: it would work on this way: Let VecTextASCII = VBA.Split(UserText), but it's VBA...
    ReDim Preserve VecTextASCII(j)
    Let StrAsc = VBA.Mid$(CStrText, i, CIntLength)
    Let VecTextASCII(j) = IIf(CBooAsc, VBA.Asc(StrAsc), StrAsc)
    Let j = j + 1
  Next
  
  Let ChrTran_asc_split = VecTextASCII
  
EH:
  Let VecTextASCII = Empty
  
End Function


' ERRORS MANNAGEMENT AND ASSERTSIONS ----------------------------------------------- '
' Errors
Private Sub Error_handler()

  If Not VBA.Err.Number = 0 Then
    Call VBA.MsgBox("Error: " & VBA.Err.Description & VBA.vbNewLine & "El texto no pudo ser encriptado/desencriptado.", vbInformation, "CHRTRANENCRYPTDECRYPTCLASS")
  End If
  On Error GoTo -1

End Sub

' Debug_assert
Private Sub Debug_assert(ByVal Cond As Boolean, Optional Origin As String = VBA.vbNullString)

  #If Debbuging Then
    Debug.Assert Cond
    If Not Cond Then Debug.Print "CTED - Assert on: " & Origin
  #End If

End Sub

' Debug_print
Private Sub Debug_print(ParamArray CPrintableData() As Variant)

  #If Debugging Then
    Debug.Print "CTED::-Debug_print: " & VBA.Join(CPrintableData, vbTab)
  #End If

End Sub

' Debug_msgbox
Private Sub Debug_msgbox(ByVal DStrWhat As String)

  #If Debugging Then
    Call VBA.MsgBox(DStrWhat, vbInformation, "CTED - " & Application.Name)
  #End If

End Sub
' CORE METHODS LIST (PRIVATE) ------------------------------------------------------ '


' CORE METHODS LIST (PUBLIC) ------------------------------------------------------- '
Public Function CHRTRANGenerateRandomKey(Optional LowWord As Single = 65, Optional UpWord As Single = 90, Optional xLength As CTED_KEYLENGTH = ctedKeyLength5) As String
  
  ' GENERATES A RANDOM STRING WITH IN A RANGE OF A-Z AND LENGTH OF 5 BY DEFAULT
  Let CHRTRANGenerateRandomKey = ChrTran_RandomWord(LowWord, UpWord, xLength)
  
End Function

Public Function CHRTRANEncryptDecrypt( _
  ByVal UserText As String, _
  Optional UserKey As String = VBA.vbNullString, _
  Optional EncDec As CTED_ENCDEC = ctedDecrypt, _
  Optional RndKeyLength As CTED_KEYLENGTH = ctedKeyLength5, _
  Optional RndKeyPosition As CTED_KEYPOS = ctedRandom, _
  Optional ResultType As CTED_TYPERES = ctedStatic) As String
  
  ' Description:
  ' UserText:         Any text to enc/dec.
  ' UserKey:          Optional. A key to enc/dec.
  ' EncDec:           Optional. Constant: Encrypt or decrypt.
  ' RndKeyLength:     Optional. Constant, by default ctedKeyLength5.
  '                   This value determines the lenght of random key.
  ' RndKeyPosition:   Optional. Works when algorithm generates its own keyText,
  '                   this value is joined/read at/from the left or right side of enc/dec text.
  '                   Doesn't work if TextKey exists. Doesn't required when decrypt.
  ' ResultType:       Optional. If static, the result text will always the same Encrypted Result,
  '                   dynamic will always result in diferent Result Encrypted text.
  '                   Doesn't work if UserKey exists. Doesn't required when decrypt.
  
  Let CHRTRANEncryptDecrypt = Chrtran_encdec(UserText, UserKey, EncDec, RndKeyLength, RndKeyPosition, ResultType)
  
End Function
' CORE METHODS LIST (PUBLIC) ------------------------------------------------------- '
' ==================== CLASS CHRTRAN ENCRYPT DECRYPT STRUCTURE ===================== '


